import list.
import nat.
import pair.
import true.
import vector.

import listt.


% Work with Aaron
zip-return-t â‡ (Nat â†’ â˜…) â†’ Nat â†’ â˜… =
  Î» L : Nat â†’ â˜… . Î» n : Nat.
    â†‘ X . n Â· (Î» _ : Nat . X) : ((Nat â†’ â˜† â†’ â˜†) â†’ â˜† â†’ â˜†)
            Â· (Î» p : Nat . Î» T : â˜… . Pair Â· (L p) Â· T)
	    Â· True .

testList â‡ Nat â†’ â˜… =
 Î» n : Nat . if-t (eqnat n Z) Â· Bool Â· (if-t (eqnat n (S Z)) Â· Nat Â· False) .

test â‡ â˜… = zip-return-t Â· testList (S (S Z)) !


% Implementation from Fridlender and Indrika
zero â‡ âˆ€ X : â˜… . X â†’ X =
  Î› X . Î» a . a .
  
succ â‡ âˆ€ A : â˜… . âˆ€ B : â˜… . âˆ€ C : â˜… . ((List Â· B) â†’ C) â†’ (List Â· (A â†’ B)) â†’ List Â· A â†’ C =
  Î› A . Î› B . Î› C . Î» n . Î» fs . Î» as . n (zap Â· A Â· B fs as) .

one-num â‡ âˆ€ A : â˜… . âˆ€ B : â˜… . (List Â· (A â†’ B)) â†’ (List Â· A) â†’ (List Â· B) =
  Î› A . Î› B . succ Â· A Â· B Â· (List Â· B) (zero Â· (List Â· B)) .

two-num â‡ âˆ€ A : â˜… . âˆ€ B : â˜… . âˆ€ C : â˜… . (List Â· (A â†’ B â†’ C)) â†’ (List Â· A) â†’ (List Â· B) â†’ (List Â· C) =
  Î› A . Î› B . Î› C . succ Â· A Â· (B â†’ C) Â· ((List Â· B) â†’ (List Â· C)) (one-num Â· B Â· C) .

% where cn is a numeral built from the above terms
% and n is the size of the lists to zip over
zipWithN â‡ âˆ€ A : â˜… . âˆ€ B : â˜… . ((List Â· A) â†’ B) â†’ A â†’ Nat â†’ B =
  Î› A . Î› B . Î» cn . Î» f . Î» n . cn (repeat Â· A f n) .

% Vector implementation
zeroV = zero .

succV â‡ âˆ€ A : â˜… . âˆ€ B : â˜… . âˆ€ C : â˜… . Î  n : Nat . ((Vector Â· B n) â†’ C) â†’ (Vector Â· (A â†’ B) n) â†’ Vector Â· A n â†’ C =
  Î› A . Î› B . Î› C . Î» vN . Î» n . Î» fs . Î» as . n (Vzap Â· A Â· B vN fs as) .

one-numV â‡ âˆ€ A : â˜… . âˆ€ B : â˜… . Î  n : Nat . (Vector Â· (A â†’ B) n) â†’ (Vector Â· A n) â†’ (Vector Â· B n) =
  Î› A . Î› B . Î» n . succV Â· A Â· B Â· (Vector Â· B n) n (zeroV Â· (Vector Â· B n)) .

two-numV â‡ âˆ€ A : â˜… . âˆ€ B : â˜… . âˆ€ C : â˜… . Î  n : Nat . (Vector Â· (A â†’ B â†’ C) n) â†’ (Vector Â· A n) â†’ (Vector Â· B n) â†’ (Vector Â· C n) =
  Î› A . Î› B . Î› C . Î» n . succV Â· A Â· (B â†’ C) Â· ((Vector Â· B n) â†’ (Vector Â· C n)) n (one-numV Â· B Â· C n) .

zipWithNV â‡ âˆ€ A : â˜… . âˆ€ B : â˜… . Î  n : Nat . ((Vector Â· A n) â†’ B) â†’ A â†’ B =
  Î› A . Î› B . Î» n . Î» cn . Î» f . cn (Vrepeat Â· A n f) .

% instances - map and zipWith
zipWith1 = zipWithN Â· (Nat â†’ Nat) Â· ((List Â· Nat) â†’ (List Â· Nat)) (one-num Â· Nat Â· Nat) .

zipWith2 = zipWithN Â· (Nat â†’ Nat â†’ Nat) Â· ((List Â· Nat) â†’ (List Â· Nat) â†’ (List Â· Nat)) (two-num Â· Nat Â· Nat Â· Nat) .

testList1 = (Cons Â· Nat (S Z) (Cons Â· Nat Z (Nil Â· Nat))) .

testList2 = (Cons Â· Nat (S Z) (Cons Â· Nat (S Z) (Nil Â· Nat))) .

map-test = zipWith1 (Î» x . add x (S Z)) (S (S Z)) testList1 !

zipWith-test = zipWith2 add (S (S Z)) testList1 testList2 !


% lifting tests
id â‡ âˆ€ A : â˜… . A â†’ A = Î› A . Î» x . x .

id-lift â‡ â˜… â†’ â˜… = â†‘ X . id Â· X : (â˜† â†’ â˜†) .

id-lift-test â‡ â˜… = id-lift Â· Bool !

% implementation from Weirich and Casinghino
arrTy â‡ (Nat â†’ â˜…) â†’ Nat â†’ â˜… =
  Î» L : Nat â†’ â˜… . Î» n : Nat.
    â†‘ X . n Â· (Î» _ : Nat . X) : ((Nat â†’ â˜† â†’ â˜†) â†’ â˜† â†’ â˜†)
            Â· (Î» p : Nat . Î» T : â˜… . T â†’ (L p))
	    Â· Bool .

arrTy-test â‡ â˜… = arrTy Â· testList (S (S Z)) !

% attempt with lists of types
arrTy2 â‡ ğ’ŒNElistt â†’ â˜… =
  Î» L : ğ’ŒNElistt . L Â· (Î» h : â˜… . Î» r : ğ’ŒNElistt . h â†’ r) Â· (Î» b : â˜… . b) Â· (List Â· Bool) .

