module Everything.

-- Implicitly indexed Mendler-style induction


{- Definition of schemes with indexed identity mappings -}
import IIdMapping. 

{- Implicitly indexed Mendler-style inductive datatypes, their constructor,
   and induction principle -}
import IFixIndM.
import IInductionM.


--  Generic datatype reuse combinators [main contribution]


{- Generic cast from richer indexed datatype (e.g. vectors) to less
   indexed datatypes (e.g. lists) and vice versa. The premises
   (conditions on schemes F and G) of reuse combinators could be taken
   as guiding principles for designing datatypes, which will allow
   datatype reuse.

   The liminations of "reuse" technique:

   1. The functors NatF0 and NatF1 are isomorphic and both give rise
      to natural numbers.  However, there is no "cast" between NatF0
      and NatF1 which hinders the reuse technique also for their least
      fixed points.

      NatF0 X = 1 + X
      NatF1 X = (1 x 1) + X

   2. Same issue happens with large elimination: 

      VecF0 A X zero    = Unit
      VecF0 A X (suc n) = A × VecF0 A X n

      VecF1 A X n = {n ≃ zero} + Σ m : Nat. {n ≃ suc m} × A × X m
-}
import ReuseForgetful.
import ReuseEnriching.


-- Examples


{- List datatype as a least fixed point of ListF identity mapping -}
import ListF.
import List.

{- Vec datatype as a least fixed point of VecF identity mapping -}
import VecF.
import Vec.

{- using generic reuse combinators for casts between List and Vec -}
import ListVecReuse.
