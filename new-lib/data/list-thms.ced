import ../stdcore.

module list-thms.

import list.
import nat.
import nat-thms/simple.
import option.

mapId : ∀ A: ★. ∀ B: ★. ∀ c: Cast ·A ·B. Π xs: List ·A. {map (elimCast -c) xs ≃ xs}
= Λ A. Λ B. Λ c. λ xs. μ ih. xs @(λ xs: List ·A. {map (elimCast -c) xs ≃ xs}) {
  | nil ➔ β
  | cons x xs ➔
    ρ (ih xs) @ z. {cons x z ≃ cons x xs} - β
  }.

-- mapping over a list with any function produces a list with the same length as the original
mapLength : ∀ A: ★. ∀ B: ★. Π f: (A ➔ B). Π xs: List ·A. {length (map f xs) ≃ length xs}
= Λ A. Λ B. λ f. λ xs. μ mapLength. xs {
  | nil ➔ χ {zero ≃ zero} - β
  | cons x xs ➔ χ { succ (length (map f xs)) ≃ succ (length xs) }
    - [ih : {length (map f xs) ≃ length xs} = mapLength xs] - ρ ih - β
  }.

-- mapping over an appended list produces the same list as appending two mapped lists.
mapAppendCommute : ∀ A: ★. ∀ B: ★. Π  f: (A ➔ B). Π xs: List ·A. Π ys: List ·A.
  {map f (append xs ys) ≃ append (map f xs) (map f ys)}
  = Λ A. Λ B. λ f. λ xs. λ ys. μ appCommute. xs {
  | nil ➔ χ {map f (append nil ys) ≃ append (map f nil) (map f ys)} - β
  | cons x xs ➔
    χ {cons (f x) (map f (append xs ys)) ≃ append (cons (f x) (map f xs)) (map f ys)}
  - [ih : {map f (append xs ys) ≃ append (map f xs) (map f ys)} = appCommute xs] - ρ ih - β
  }.

-- append and length (see vappend in data/vec.ced)
appendLen : ∀ A: ★. Π xs: List ·A. Π ys: List ·A. { length (append xs ys) ≃ add (length xs) (length ys) }
= ● .

-- List ·A is the free monoid over A
-- nil is the left and right neutral element of append
appendNilL : ∀ A: ★. Π xs: List ·A. {append xs nil ≃ xs}
= Λ A. λ xs. μ appendNil. xs {
  | nil ➔ χ {append nil nil ≃ nil} - β
  | cons x xs ➔ χ {cons x (append xs nil) ≃ cons x xs} - [ih : { append xs nil ≃ xs} = appendNil xs] - ρ ih - β
  }.

appendNilR : ∀ A: ★. Π xs: List ·A. {append nil xs ≃ xs}
= Λ A. λ xs. β.

appendAssoc : ∀ A: ★. Π xs: List ·A. Π ys: List ·A. Π zs: List ·A.
  {append (append xs ys) zs ≃ append xs (append ys zs)}
= Λ A. λ xs. λ ys. λ zs. μ Assoc. xs {
  | nil ➔ χ {append (append nil ys) zs ≃ append nil (append ys zs)} - β
  | cons x xs ➔ χ {cons x (append (append xs ys) zs) ≃ append (cons x xs) (append ys zs)}
    - [ih : { append (append xs ys) zs ≃ append xs (append ys zs) } = Assoc xs] - ρ ih - β
  }.

consInj : ∀ A: ★. Π x: A. Π y: A. Π xs: List ·A. Π ys: List ·A. { cons x xs ≃ cons y ys } ➔ { xs ≃ ys }
= Λ A. λ x. λ y. λ xs. λ ys. λ eq. ρ eq @ t. {tail t ≃ tail (cons y ys)} - β.

consInj2 : ∀ A: ★. Π x: A. Π y: A. Π xs: List ·A. Π ys: List ·A. { cons x xs ≃ cons y ys } ➔ { x ≃ y }
= Λ A. λ x. λ y. λ xs. λ ys. λ eq. ρ eq @ h. {headSafe h (isCons h) ≃ headSafe (cons y ys) (isCons (cons y ys))} - β.
appendIdUnique : ∀ A: ★. Π xs: List ·A. Π ys: List ·A. {xs ≃ append xs ys} ➔ {ys ≃ nil}
= Λ A. λ xs. λ ys.
  μ IdUnique. xs {
  | nil ➔ χ ({nil ≃ append nil ys} ➔ {ys ≃ nil}) - λ eq: { nil ≃ ys }. ρ eq - β
  | cons x xs ➔ χ ({cons x xs ≃ cons x (append xs ys)} ➔ {ys ≃ nil})
    - [xs' = to/List -isType/IdUnique xs]
    - λ eq. IdUnique xs (consInj x x xs' (append xs' ys) eq)
  }.


-- proper eqList
import decidable.

-- Decision is in data/decidable
-- Not is in core/bot.
decEqList : ∀ A: ★. (Π x: A. Π y: A. Decision ·{x ≃ y}) ➔ Π xs: List ·A. Π ys: List ·A. Decision ·{ xs ≃ ys }
= Λ A. λ eq. λ xs. μ decEqList. xs {
  | nil ➔ λ ys. σ ys {
    | nil ➔ decYes ·{nil ≃ nil} β
    | cons y ys ➔ decNo ·{nil ≃ cons y ys} (λ eq'. δ - eq')
    }
  | cons x xs ➔ λ ys. σ ys {
    | nil ➔ decNo ·{cons x xs ≃ nil} (λ eq'. δ - eq')
    | cons y ys ➔ σ (eq x y) {
      | decYes proof ➔ σ (decEqList xs ys) {
      	| decYes proof' ➔ decYes (ρ proof - ρ proof' - β)
	| decNo proof' ➔ decNo λ e. proof' (consInj x y (to/List -isType/decEqList xs) ys e)
      	}
      | decNo proof ➔ decNo λ eq'. proof (consInj2 x y (to/List -isType/decEqList xs) ys eq') 
      }
    }
}.

-- _ : FmapId ·List map
-- _ : FmapComp ·List map
import ../categories/functor .

listMapId : FmapId ·List map
= Λ X. Λ Y. λ f. λ i. λ xs. μ listMapId. xs {
  | nil ➔ β
  | cons x xs ➔ χ {cons (f x) (map f xs) ≃ cons x xs}
    - [ih : {map f xs ≃ xs} = listMapId xs]
    - [lem : { f x ≃ x } = i x]
    - ρ ih - ρ lem - β
  }.

listMapComp :FmapComp ·List map
= Λ X. Λ Y. Λ Z. λ f. λ g. λ xs.
  [h : X ➔ Z = λ x. f (g x)]
  - μ listMapComp. xs {
  | nil ➔ β
  | cons x xs ➔ χ {cons (f (g x)) (map f (map g xs)) ≃ cons (h x) (map h xs)}
    - [ih : {map f (map g xs) ≃ map h xs} = listMapComp xs] - ρ ih - β
  }.

-- injectivity of List
injList : ∀ A: ★. ∀ B: ★. Cast ·(List ·A) ·(List ·B) ➾ Cast ·A ·B
= Λ A. Λ B. Λ idL.
  [a2l = λ a: A. cons a (nil ·A)]
- [f : A ➔ B = λ a. headSafe (elimCast -idL (a2l a)) β]
- intrCast -f -(λ _. β).

tailDrop: ∀ A: ★. Π n: Nat. Π l: List ·A. {tail (drop n l) ≃ drop n (tail l)}
= Λ A. λ n. μ ih. n {
  | zero ➔ λ l. β
  | succ n ➔ λ l. ρ+ (ih n (tail l)) - β
  }.

compDrop: ∀ A: ★. Π m: Nat. Π n: Nat. Π l: List ·A. {drop m (drop n l) ≃ drop (add m n) l}
= Λ A. λ m. μ ih. m {
  | zero ➔ λ n. λ l. β
  | succ m ➔ λ n. λ l.
    ρ+ (tailDrop n l) - ρ+ (ih m n (tail l)) - β
  }.

-- property of being a suffix
ListSuffix : Π A: ★. List ·A ➔ List ·A ➔ ★
= λ A: ★. λ xs: List ·A. λ ys: List ·A.
  ι n: Nat. { drop n ys ≃ xs } .

nilSuffix : ∀ A: ★. Π xs: List ·A. ListSuffix ·A (nil ·A) xs
= Λ A. λ xs.
  [pf : { drop (length xs) xs ≃ nil }
     = μ ns. xs {
       | nil ➔ β
       | cons x xs ➔ ns xs
       }]
- [ length xs , ρ pf - β{|length xs|} ] .
