Index: src/classify.agda
===================================================================
--- src/classify.agda	(revision 27194)
+++ src/classify.agda	(working copy)
@@ -269,8 +269,8 @@
         cont (just tp) = get-ctxt (Î» Î“ â†’ spanMr (just (hnf Î“ unfold-head tp tt)))
         cont nothing = spanMr nothing 
 check-term subject (just tp) =
-  get-ctxt (Î» Î“ â†’ 
-    check-termi subject (just (if is-intro-form subject then (hnf-instantiate-iota Î“ subject tp ff) else (hnf Î“ unfold-head tp tt))))
+  get-ctxt (Î» Î“ â†’
+    check-termi subject (just (if is-intro-form subject then (hnf-instantiate-iota Î“ (qualif-term Î“ subject) tp ff) else (hnf Î“ unfold-head tp tt))))
 
 check-type subject nothing = check-typei subject nothing
 check-type subject (just k) = get-ctxt (Î» Î“ â†’ check-typei subject (just (hnf Î“ unfold-head k tt)))
@@ -307,7 +307,7 @@
   where cont : type â†’ spanM (maybe type)
         cont (Abs pi b pi' x (Tkk k) tp2) = 
            check-type tp' (just k) â‰«span 
-           get-ctxt (Î» Î“ â†’ spanMr (just (subst-type Î“ tp' x tp2)))
+           get-ctxt (Î» Î“ â†’ spanMr (just (subst-type Î“ (qualif-type Î“ tp') x tp2)))
         cont tp'' =
           get-ctxt (Î» Î“ â†’ 
             spanM-add (AppTp-span t tp' (maybe-to-checking tp)
@@ -329,7 +329,7 @@
         cont'' : maybe type â†’ spanM (maybe type)
         cont'' nothing =
           spanM-add (AppTp-span t tp' (maybe-to-checking tp) []) â‰«span spanMr nothing
-        cont'' (just htp) = get-ctxt (Î» Î“ â†’ cont (hnf-instantiate-iota Î“ t htp tt))
+        cont'' (just htp) = get-ctxt (Î» Î“ â†’ cont (hnf-instantiate-iota Î“ (qualif-term Î“ t) htp tt))
 -- =BUG= =ACG= =31= Maybe pull out repeated code in helper functions?
 check-termi (App t m t') tp =
   check-term t nothing â‰«=span cont'' â‰«=spanr cont' tp 
@@ -350,7 +350,7 @@
           if check-term-app-matching-erasures m b then
              (check-term t' (just tp1) â‰«span 
               get-ctxt (Î» Î“ â†’ 
-                check-termi-return Î“ (App t m t') (subst-type Î“ t' x tp2)))
+                check-termi-return Î“ (App t m t') (subst-type Î“ (qualif-term Î“ t') x tp2)))
           else
             check-term-app-erased-error (maybe-to-checking tp) m t t' (Abs pi b pi' x (Tkt tp1) tp2)
         cont m tp' =
@@ -378,7 +378,7 @@
                           (check-for-type-mismatch Î“ "synthesized" tp tp' ++ hnf-expected-type-if Î“ (just tp) [])))
         cont'' : maybe type â†’ spanM (maybe type)
         cont'' nothing = spanM-add (App-span t t' (maybe-to-checking tp) []) â‰«span spanMr nothing
-        cont'' (just htp) = get-ctxt (Î» Î“ â†’ cont m (hnf-instantiate-iota Î“ t htp tt))
+        cont'' (just htp) = get-ctxt (Î» Î“ â†’ cont m (hnf-instantiate-iota Î“ (qualif-term Î“ t) htp tt))
 
 check-termi (Let pi d t) mtp =
   spanM-add (punctuation-span "Let" pi (posinfo-plus pi 3)) â‰«span
@@ -454,7 +454,7 @@
   where this-span : ctxt â†’ tk â†’ optClass â†’ ğ•ƒ tagged-val â†’ span
         this-span Î“ _ NoClass tvs = Lam-span Î“ checking pi l x oc t tvs
         this-span Î“ atk (SomeClass atk') tvs = 
-          if conv-tk Î“ atk' atk then
+          if conv-tk Î“ (qualif-tk Î“ atk') atk then
             Lam-span Î“ checking pi l x oc t tvs
           else
             Lam-span Î“ checking pi l x oc t (lambda-bound-var-conv-error Î“ x atk atk' tvs)
@@ -650,12 +650,13 @@
 
 check-termi (Chi pi (Atype tp) t) mtp = 
   check-type tp (just star) â‰«span
-  check-term t (just tp) â‰«span cont mtp
+  get-ctxt Î» Î“ â†’
+  check-term t (just (qualif-type Î“ tp)) â‰«span cont mtp
   where cont : (m : maybe type) â†’ spanM (check-ret m)
         cont nothing = get-ctxt (Î» Î“ â†’ spanM-add (Chi-span Î“ pi (Atype tp) t synthesizing []) â‰«span spanMr (just tp))
         cont (just tp') =
           get-ctxt (Î» Î“ â†’ 
-           spanM-add (Chi-span Î“ pi (Atype tp) t checking (check-for-type-mismatch Î“ "asserted" tp' tp)))
+           spanM-add (Chi-span Î“ pi (Atype tp) t checking (check-for-type-mismatch Î“ "asserted" tp' (qualif-type Î“ tp))))
 check-termi (Chi pi NoAtype t) (just tp) = 
   check-term t nothing â‰«=span cont 
   where cont : (m : maybe type) â†’ spanM âŠ¤
@@ -733,10 +734,13 @@
 check-termi (IotaPair pi t1 t2 ot pi') (just (IotaEx pi1 Iota pi2 x (SomeType tp1) tp2)) =
   check-term t1 (just tp1) â‰«span
   get-ctxt (Î» Î“ â†’ 
-    check-term t2 (just (subst-type Î“ t1 x tp2)) â‰«span
-    add-spans-if ot t1 t2 â‰«span
+    let t1' = qualif-term Î“ t1 in
+    let t2' = qualif-term Î“ t2 in
+    check-term t2 (just (subst-type Î“ t1' x tp2)) â‰«span
+    add-spans-if ot t1' t2' â‰«span
+    -- TODO why another get-ctxt here?
     get-ctxt (Î» Î“ â†’ 
-    spanM-add (IotaPair-span pi pi' checking (expected-type Î“ (IotaEx pi1 Iota pi2 x (SomeType tp1) tp2) :: (check-conv-if Î“ ot t1 t2)))))
+    spanM-add (IotaPair-span pi pi' checking (expected-type Î“ (IotaEx pi1 Iota pi2 x (SomeType tp1) tp2) :: (check-conv-if Î“ ot t1' t2')))))
   where err : ctxt â†’ string â†’ term â†’ tagged-val
         err Î“ which t = ("Hnf of the " ^ which ^ " component: ") , term-to-string Î“ tt (hnf Î“ unfold-head t tt)
         add-spans-if : optTerm â†’ term â†’ term â†’ spanM âŠ¤
@@ -831,7 +835,7 @@
    check-tk atk â‰«span
    spanM-add (punctuation-span "Lambda (type)" pi (posinfo-plus pi 1)) â‰«span
    get-ctxt (Î» Î“ â†’ 
-   spanM-add (if conv-tk Î“ atk atk' then
+   spanM-add (if conv-tk Î“ (qualif-tk Î“ atk) atk' then
                 TpLambda-span pi x atk body checking [ kind-data Î“ k ]
               else
                 TpLambda-span pi x atk body checking (lambda-bound-var-conv-error Î“ x atk' atk [ kind-data Î“ k ])) â‰«span
@@ -892,7 +896,7 @@
         cont (KndPi _ _ x (Tkt tp') k') = 
           check-term t (just tp') â‰«span 
           get-ctxt (Î» Î“ â†’ 
-            spanMr (just (subst-kind Î“ t x k')))
+            spanMr (just (subst-kind Î“ (qualif-term Î“ t) x k')))
         cont k' = get-ctxt (Î» Î“ â†’ 
                    spanM-add (TpAppt-span tp t (maybe-to-checking k)
                                (error-data ("The kind computed for the head of the type application does"
@@ -928,7 +932,7 @@
         cont (KndPi _ _ x (Tkk k'') k') = 
           check-type tp' (just k'') â‰«span 
           get-ctxt (Î» Î“ â†’ 
-            spanMr (just (subst-kind Î“ tp' x k')))
+            spanMr (just (subst-kind Î“ (qualif-type Î“ tp') x k')))
         cont k' = get-ctxt (Î» Î“ â†’ 
                   spanM-add (TpApp-span tp tp' (maybe-to-checking k)
                                (error-data ("The kind computed for the head of the type application does"
@@ -1002,7 +1006,7 @@
   check-kind k
 check-kind (Star pi) = spanM-add (Star-span pi checking)
 check-kind (KndVar pi x ys) =
-  get-ctxt (Î» Î“ â†’ helper (ctxt-lookup-kind-var-def Î“ x) ys)
+  get-ctxt (Î» Î“ â†’ helper (ctxt-lookup-kind-var-qdef Î“ x) ys)
   where helper : maybe (params Ã— kind) â†’ args â†’ spanM âŠ¤
         helper (just (ps , k)) ys =
           check-args-against-params ps ys â‰«=span Î» m â†’
Index: src/conversion.agda
===================================================================
--- src/conversion.agda	(revision 27194)
+++ src/conversion.agda	(working copy)
@@ -185,6 +185,8 @@
 hnf{KIND} Î“ u x hd = x
 
 hnf{LIFTINGTYPE} Î“ u x hd = x
+hnf{QUALIF} Î“ u x hd = x
+hnf{ARG} Î“ u x hd = x
 
 hnf-tk Î“ u (Tkk k) = Tkk (hnf Î“ u k tt)
 hnf-tk Î“ u (Tkt tp) = Tkt (hnf Î“ u tp ff)
@@ -289,3 +291,11 @@
 conv-tty* Î“ (ttype t :: args) (ttype t' :: args') = conv-type Î“ t t' && conv-tty* Î“ args args'
 conv-tty* Î“ _ _ = ff
 
+hnf-qualif-term : ctxt â†’ term â†’ term
+hnf-qualif-term Î“ t = hnf Î“ unfold-head (qualif-term Î“ t) tt
+
+hnf-qualif-type : ctxt â†’ type â†’ type
+hnf-qualif-type Î“ t = hnf Î“ unfold-head (qualif-type Î“ t) tt
+
+hnf-qualif-kind : ctxt â†’ kind â†’ kind
+hnf-qualif-kind Î“ t = hnf Î“ unfold-head (qualif-kind Î“ t) tt
Index: src/ctxt.agda
===================================================================
--- src/ctxt.agda	(revision 27194)
+++ src/ctxt.agda	(working copy)
@@ -2,73 +2,11 @@
 
 open import lib
 open import cedille-types
+open import ctxt-types public
+open import subst
 open import general-util
 open import syntax-util
 
-location : Set
-location = string Ã— posinfo -- file path and starting position in the file 
-
-{- we will generally keep classifiers of variables in hnf in the ctxt, although
-   we will not necessarily unfold recursive type definitions. -}
-
-defScope : Set
-defScope = ğ”¹
-
-localScope : defScope
-localScope = tt
-
-globalScope : defScope
-globalScope = ff
-
-defParams : Set
-defParams = maybe params
-
-data ctxt-info : Set where
-
-  -- for declaring a variable to have a given type (with no definition)
-  term-decl : type â†’ ctxt-info
-
-  -- for defining a variable to equal a term with a given type
-  term-def : defParams â†’ term â†’ type â†’ ctxt-info
-
-  -- for untyped term definitions 
-  term-udef : defParams â†’ term â†’ ctxt-info
-
-  -- for declaring a variable to have a given kind (with no definition)
-  type-decl : kind â†’ ctxt-info
-
-  -- for defining a variable to equal a type with a given kind
-  type-def : defParams â†’ type â†’ kind â†’ ctxt-info
-
-  -- for defining a variable to equal a kind
-  kind-def : params â†’ params â†’ kind â†’ ctxt-info
-
-  -- to rename a variable at any level to another
-  rename-def : var â†’ ctxt-info
-
-  -- representing a declaration of a variable with no other information about it
-  var-decl : ctxt-info
-
-sym-info : Set
-sym-info = ctxt-info Ã— location
-
--- module filename, parameters, and qualifying substitution
-mod-info : Set
-mod-info = string Ã— params Ã— qualif
-
-is-term-level : ctxt-info â†’ ğ”¹
-is-term-level (term-decl _) = tt
-is-term-level (term-def _ _ _) = tt
-is-term-level (term-udef _ _) = tt
-is-term-level _ = ff
-
-data ctxt : Set where
-  mk-ctxt : (mod : mod-info) â†’                     -- current module
-            (syms : trie (ğ•ƒ string)) â†’             -- map each filename to the symbols declared in that file
-            (i : trie sym-info) â†’                  -- map symbols (from Cedille files) to their ctxt-info and location
-            (sym-occurrences : trie (ğ•ƒ (var Ã— posinfo Ã— string))) â†’  -- map symbols to a list of definitions they occur in (and relevant file info)
-            ctxt
-
 new-ctxt : (filename : string) â†’ ctxt
 new-ctxt fn = mk-ctxt (fn , ParamsNil , empty-trie) empty-trie empty-trie empty-trie
 
@@ -84,51 +22,68 @@
 ctxt-restore-info* Î“ ((x , m) :: ms) = ctxt-restore-info* (ctxt-restore-info Î“ x m) ms
 
 ctxt-term-decl : posinfo â†’ var â†’ type â†’ ctxt â†’ ctxt
-ctxt-term-decl p v t (mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt (fn , ps , q)
-                                                    (trie-insert-append syms fn v)
-                                                    (trie-insert i v (term-decl t , (fn , p)))
-                                                    symb-occs
+ctxt-term-decl p v t (mk-ctxt (fn , ps , q) syms i symb-occs) =
+  mk-ctxt (fn , ps , q) syms (trie-insert i v (term-decl t , (fn , p))) symb-occs
 
 ctxt-type-decl : posinfo â†’ var â†’ kind â†’ ctxt â†’ ctxt
-ctxt-type-decl p v k (mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt (fn , ps , q)
-                                                    (trie-insert-append syms fn v)
-                                                    (trie-insert i v (type-decl k , (fn , p)))
-                                                    symb-occs
+ctxt-type-decl p v k (mk-ctxt (fn , ps , q) syms i symb-occs) =
+  mk-ctxt (fn , ps , q) syms (trie-insert i v (type-decl k , (fn , p))) symb-occs
 
 def-params : defScope â†’ params â†’ defParams
 def-params tt ps = nothing
 def-params ff ps = just ps
 
--- TODO roll "hnf Î“ unfold-head t tt" into ctxt-*-def, after qualification
-ctxt-type-def : posinfo â†’ defScope â†’ var â†’ type â†’ kind â†’ ctxt â†’ ctxt
-ctxt-type-def p s v t k (mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt (fn , ps , qualif-insert-params q fn v ps)
-                                                    (trie-insert-append syms fn v)
-                                                    (trie-insert i v (type-def (def-params s ps) (qualif-type q t) (qualif-kind q k) , (fn , p)))
-                                                    symb-occs
+-- TODO add renamectxt to avoid capture bugs
+inst-type : ctxt â†’ params â†’ args â†’ type â†’ type
+inst-type Î“ ps as = substs-type Î“ (mk-inst ps as)
+
+inst-kind : ctxt â†’ params â†’ args â†’ kind â†’ kind
+inst-kind Î“ ps as = substs-kind Î“ (mk-inst ps as)
+
+-- TODO substs-params
+inst-params : ctxt â†’ params â†’ args â†’ params â†’ params
+inst-params Î“ ps as qs = qs
+
+qualif-term : ctxt â†’ term â†’ term
+qualif-term Î“@(mk-ctxt (_ , _ , Ïƒ) _ _ _) = substs-term Î“ Ïƒ
+
+qualif-type : ctxt â†’ type â†’ type
+qualif-type Î“@(mk-ctxt (_ , _ , Ïƒ) _ _ _) = substs-type Î“ Ïƒ
+
+qualif-kind : ctxt â†’ kind â†’ kind
+qualif-kind Î“@(mk-ctxt (_ , _ , Ïƒ) _ _ _) = substs-kind Î“ Ïƒ
+
+qualif-tk : ctxt â†’ tk â†’ tk
+qualif-tk Î“ (Tkt t) = Tkt (qualif-type Î“ t)
+qualif-tk Î“ (Tkk k) = Tkk (qualif-kind Î“ k)
 
 ctxt-kind-def : posinfo â†’ var â†’ params â†’ kind â†’ ctxt â†’ ctxt
-ctxt-kind-def p v ps2 k (mk-ctxt (fn , ps1 , q) syms i symb-occs) = mk-ctxt (fn , ps1 , qualif-insert-params q fn v ps1)
-                                                    (trie-insert-append syms fn v)
-                                                    (trie-insert i v (kind-def ps1 ps2 k , (fn , p)))
-                                                    symb-occs
+ctxt-kind-def p v ps2 k (mk-ctxt (fn , ps1 , q) syms i symb-occs) = mk-ctxt
+  (fn , ps1 , qualif-insert-params q fn v ps1)
+  (trie-insert-append syms fn v)
+  (trie-insert i (fn # v) (kind-def ps1 ps2 k , (fn , p)))
+  symb-occs
+
+ctxt-type-def : posinfo â†’ defScope â†’ var â†’ type â†’ kind â†’ ctxt â†’ ctxt
+ctxt-type-def p s v t k Î“@(mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt
+  (fn , ps , qualif-insert-params q fn v ps)
+  (trie-insert-append syms fn v)
+  (trie-insert i (fn # v) (type-def (def-params s ps) t k , (fn , p)))
+  symb-occs
 
 ctxt-term-def : posinfo â†’ defScope â†’ var â†’ term â†’ type â†’ ctxt â†’ ctxt
-ctxt-term-def p s v t tp (mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt (fn , ps , qualif-insert-params q fn v ps)
-                                                    (trie-insert-append syms fn v)
-                                                    (trie-insert i v (term-def (def-params s ps) (qualif-term q t) (qualif-type q tp) , (fn , p)))
-                                                    symb-occs
+ctxt-term-def p s v t tp Î“@(mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt
+  (fn , ps , qualif-insert-params q fn v ps)
+  (trie-insert-append syms fn v)
+  (trie-insert i (fn # v) (term-def (def-params s ps) t tp , (fn , p)))
+  symb-occs
 
 ctxt-term-udef : posinfo â†’ defScope â†’ var â†’ term â†’ ctxt â†’ ctxt
-ctxt-term-udef p s v t (mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt (fn , ps , qualif-insert-params q fn v ps)
-                                                    (trie-insert-append syms fn v)
-                                                    (trie-insert i v (term-udef (def-params s ps) (qualif-term q t) , (fn , p)))
-                                                    symb-occs
-
-ctxt-var-decl : posinfo â†’ var â†’ ctxt â†’ ctxt
-ctxt-var-decl p v (mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt (fn , ps , q)
-                                                    (trie-insert-append syms fn v)
-                                                    (trie-insert i v (var-decl , (fn , p)))
-                                                    symb-occs
+ctxt-term-udef p s v t Î“@(mk-ctxt (fn , ps , q) syms i symb-occs) = mk-ctxt
+  (fn , ps , qualif-insert-params q fn v ps)
+  (trie-insert-append syms fn v)
+  (trie-insert i (fn # v) (term-udef (def-params s ps) t , (fn , p)))
+  symb-occs
 
 -- TODO not sure how this and renaming interacts with module scope
 ctxt-var-decl-if : posinfo â†’ var â†’ ctxt â†’ ctxt
@@ -136,7 +91,9 @@
 ... | mk-ctxt (fn , ps , q) syms i symb-occs with trie-lookup i v
 ... | just (rename-def _ , _) = Î“
 ... | just (var-decl , _) = Î“
-... | _ = mk-ctxt (fn , ps , q) (trie-insert-append syms fn v)
+... | _ = mk-ctxt
+  (fn , ps , q)
+  syms
   (trie-insert i v (var-decl , (fn , p)))
   symb-occs
 
@@ -152,10 +109,10 @@
 {- add a renaming mapping the first variable to the second, unless they are equal.
    Notice that adding a renaming for v will overwrite any other declarations for v. -}
 ctxt-rename : posinfo â†’ var â†’ var â†’ ctxt â†’ ctxt
-ctxt-rename p v v' (mk-ctxt (fn , ps , q) syms i symb-occs) = 
-  (mk-ctxt (fn , ps , q) (trie-insert-append syms fn v)
-      (trie-insert i v (rename-def v' , (fn , p)))
-      symb-occs)
+ctxt-rename p v v' (mk-ctxt (fn , ps , q) syms i symb-occs) =
+  mk-ctxt (fn , ps , q) syms
+    (trie-insert i v (rename-def v' , (fn , p)))
+    symb-occs
 
 ctxt-tk-decl : posinfo â†’ var â†’ tk â†’ ctxt â†’ ctxt
 ctxt-tk-decl p x (Tkt t) Î“ = ctxt-term-decl p x t Î“ 
@@ -168,49 +125,59 @@
 -- look for a defined kind for the given var, which is assumed to be a type,
 -- then instantiate its parameters
 env-lookup-type-var : ctxt â†’ var â†’ args â†’ maybe kind
-env-lookup-type-var (mk-ctxt _ _ i _) v as with trie-lookup i v
-... | just (type-def (just ps) _ k , _) = just (inst-kind ps as k)
+env-lookup-type-var Î“@(mk-ctxt _ _ i _) v as with trie-lookup i v
+... | just (type-def (just ps) _ k , _) = just (inst-kind Î“ ps as k)
 ... | _ = nothing
 
 -- look for a declared kind for the given var, which is assumed to be a type,
 -- otherwise look for a qualified defined kind
 ctxt-lookup-type-var : ctxt â†’ var â†’ maybe kind
 ctxt-lookup-type-var Î“@(mk-ctxt (_ , _ , q) _ i _) v with trie-lookup i v
-... | just (type-decl k , _) = just (qualif-kind q k)
-... | just (type-def nothing _ k , _) = just (qualif-kind q k)
+... | just (type-decl k , _) = just (qualif-kind Î“ k)
+... | just (type-def nothing _ k , _) = just (qualif-kind Î“ k)
 ... | _ with trie-lookup q v
 ... | just (v' , as) = env-lookup-type-var Î“ v' as
 ... | _ = nothing
 
 env-lookup-term-var : ctxt â†’ var â†’ args â†’ maybe type
-env-lookup-term-var (mk-ctxt _ _ i _) v as with trie-lookup i v
-... | just (term-def (just ps) _ t , _) = just (inst-type ps as t)
+env-lookup-term-var Î“@(mk-ctxt _ _ i _) v as with trie-lookup i v
+... | just (term-def (just ps) _ t , _) = just (inst-type Î“ ps as t)
 ... | _ = nothing
 
 ctxt-lookup-term-var : ctxt â†’ var â†’ maybe type
 ctxt-lookup-term-var Î“@(mk-ctxt (_ , _ , q) _ i _) v with trie-lookup i v
-... | just (term-decl t , _) = just (qualif-type q t)
-... | just (term-def nothing _ t , _) = just (qualif-type q t)
+... | just (term-decl t , _) = just (qualif-type Î“ t)
+... | just (term-def nothing _ t , _) = just (qualif-type Î“ t)
 ... | _ with trie-lookup q v
 ... | just (v' , as) = env-lookup-term-var Î“ v' as
 ... | _ = nothing
 
 env-lookup-tk-var : ctxt â†’ var â†’ args â†’ maybe tk
-env-lookup-tk-var (mk-ctxt _ _ i _) v as with trie-lookup i v
-... | just (type-def (just ps) _ k , _) = just (Tkk (inst-kind ps as k))
-... | just (term-def (just ps) _ t , _) = just (Tkt (inst-type ps as t))
+env-lookup-tk-var Î“@(mk-ctxt _ _ i _) v as with trie-lookup i v
+... | just (type-def (just ps) _ k , _) = just (Tkk (inst-kind Î“ ps as k))
+... | just (term-def (just ps) _ t , _) = just (Tkt (inst-type Î“ ps as t))
 ... | _ = nothing
 
 ctxt-lookup-tk-var : ctxt â†’ var â†’ maybe tk
 ctxt-lookup-tk-var Î“@(mk-ctxt (_ , _ , q) _ i _) v with trie-lookup i v
-... | just (type-decl k , _) = just (Tkk (qualif-kind q k))
-... | just (type-def nothing _ k , _) = just (Tkk (qualif-kind q k))
-... | just (term-decl t , _) = just (Tkt (qualif-type q t))
-... | just (term-def nothing _ t , _) = just (Tkt (qualif-type q t))
+... | just (type-decl k , _) = just (Tkk (qualif-kind Î“ k))
+... | just (type-def nothing _ k , _) = just (Tkk (qualif-kind Î“ k))
+... | just (term-decl t , _) = just (Tkt (qualif-type Î“ t))
+... | just (term-def nothing _ t , _) = just (Tkt (qualif-type Î“ t))
 ... | _ with trie-lookup q v
 ... | just (v' , as) = env-lookup-tk-var Î“ v' as
 ... | _ = nothing
 
+env-lookup-kind-var-qdef : ctxt â†’ var â†’ args â†’ maybe (params Ã— kind)
+env-lookup-kind-var-qdef Î“@(mk-ctxt _ _ i _) v as with trie-lookup i v
+... | just (kind-def ps1 ps2 k , _) = just (inst-params Î“ ps1 as ps2 , inst-kind Î“ ps1 as k)
+... | _ = nothing
+
+ctxt-lookup-kind-var-qdef : ctxt â†’ var â†’ maybe (params Ã— kind)
+ctxt-lookup-kind-var-qdef Î“@(mk-ctxt (_ , _ , q) _ i _) v with trie-lookup q v
+... | just (v' , as) = env-lookup-kind-var-qdef Î“ v' as
+... | _ = nothing
+
 ctxt-lookup-term-var-def : ctxt â†’ var â†’ maybe term
 ctxt-lookup-term-var-def (mk-ctxt _ _ i _) v with trie-lookup i v
 ... | just (term-def nothing t _ , _) = just t
@@ -227,12 +194,9 @@
 
 ctxt-lookup-kind-var-def : ctxt â†’ var â†’ maybe (params Ã— kind)
 ctxt-lookup-kind-var-def (mk-ctxt _ _ i _) x with trie-lookup i x
-... | just (kind-def _ ps k , _) = just (ps , k)
+... | just (kind-def ps1 ps2 k , _) = just (append-params ps1 ps2 , k)
 ... | _ = nothing
 
-ctxt-binds-var : ctxt â†’ var â†’ ğ”¹
-ctxt-binds-var (mk-ctxt (_ , _ , q) _ i _) x = trie-contains q x || trie-contains i x
-
 ctxt-lookup-occurrences : ctxt â†’ var â†’ ğ•ƒ (var Ã— posinfo Ã— string)
 ctxt-lookup-occurrences (mk-ctxt _ _ _ symb-occs) symbol with trie-lookup symb-occs symbol
 ... | just l = l
@@ -251,6 +215,7 @@
 ctxt-set-current-mod : ctxt â†’ mod-info â†’ ctxt
 ctxt-set-current-mod (mk-ctxt _ syms i symb-occs) m = mk-ctxt m syms i symb-occs
 
+-- TODO I think this should trie-remove the List occurrence of the filename lookup of syms
 ctxt-clear-symbol : ctxt â†’ string â†’ ctxt
 ctxt-clear-symbol (mk-ctxt f syms i symb-occs) x = mk-ctxt f (trie-remove syms x) (trie-remove i x) symb-occs
 
@@ -260,11 +225,11 @@
 
 ctxt-clear-symbols-of-file : ctxt â†’ (filename : string) â†’ ctxt
 ctxt-clear-symbols-of-file (mk-ctxt f syms i symb-occs) fn = mk-ctxt f (trie-insert syms fn [])
-                                                                  (hremove i (trie-lookupğ•ƒ syms fn))
+                                                                  (hremove i fn (trie-lookupğ•ƒ syms fn))
                                                                   symb-occs
-  where hremove : âˆ€ {A : Set} â†’ trie A â†’ ğ•ƒ string â†’ trie A
-        hremove i [] = i
-        hremove i (x :: xs) = hremove (trie-remove i x) xs
+  where hremove : âˆ€ {A : Set} â†’ trie A â†’ var â†’ ğ•ƒ string â†’ trie A
+        hremove i fn [] = i
+        hremove i fn (x :: xs) = hremove (trie-remove i (fn # x)) fn xs
 
 ctxt-initiate-file : ctxt â†’ (filename : string) â†’ ctxt
 ctxt-initiate-file Î“ fn = ctxt-set-current-file (ctxt-clear-symbols-of-file Î“ fn) fn
Index: src/general-util.agda
===================================================================
--- src/general-util.agda	(revision 27194)
+++ src/general-util.agda	(working copy)
@@ -25,7 +25,7 @@
 trie-lookupd t s d | just x = x
 
 trie-lookup-else : âˆ€{A : Set} â†’ A â†’ trie A â†’ string â†’ A
-trie-lookup-else x t s = trie-lookupd t s x
+trie-lookup-else d t s = trie-lookupd t s d
 
 trie-single : âˆ€{A : Set} â†’ string â†’ A â†’ trie A
 trie-single s x = trie-insert empty-trie s x
Index: src/is-free.agda
===================================================================
--- src/is-free.agda	(revision 27194)
+++ src/is-free.agda	(working copy)
@@ -3,7 +3,7 @@
 open import lib
 
 open import cedille-types
-open import ctxt
+open import ctxt-types
 open import syntax-util
 
 is-free-e = ğ”¹
@@ -105,10 +105,13 @@
 is-free-in-maybeAtype ce x (Atype T) = is-free-in-type ce x T
 
 is-free-in : {ed : exprd} â†’ is-free-e â†’ var â†’ âŸ¦ ed âŸ§ â†’ ğ”¹
-is-free-in{TERM} e x t = is-free-in-term e x t 
+is-free-in{TERM} e x t = is-free-in-term e x t
+is-free-in{ARG} e x (TermArg t) = is-free-in-term e x t
 is-free-in{TYPE} e x t = is-free-in-type e x t 
+is-free-in{ARG} e x (TypeArg t) = is-free-in-type e x t
 is-free-in{KIND} e x t = is-free-in-kind e x t 
 is-free-in{LIFTINGTYPE} e x t = is-free-in-liftingType e x t 
+is-free-in{QUALIF} e x (x' , as) = x =string x' || is-free-in-args e x as
 
 abs-tk : lam â†’ var â†’ tk â†’ type â†’ type
 abs-tk l x (Tkk k) tp = Abs posinfo-gen All posinfo-gen x (Tkk k) tp
Index: src/process-cmd.agda
===================================================================
--- src/process-cmd.agda	(revision 27194)
+++ src/process-cmd.agda	(working copy)
@@ -42,28 +42,33 @@
 
 process-cmd (mk-toplevel-state use-cede make-rkt ip fns is Î“) (DefTermOrType (DefTerm pi x (Type tp) t) pi') tt {- check -} = 
   set-ctxt Î“ â‰«span
-  check-type tp (just star) â‰«span 
-  check-term t (just tp) â‰«span 
+  check-type tp (just star) â‰«span
+  let tp' = qualif-type Î“ tp in
+  check-term t (just tp') â‰«span 
   get-ctxt (Î» Î“ â†’ 
     let t = erase-term t in
-    let Î“' = (ctxt-term-def pi globalScope x (hnf Î“ unfold-head t tt) tp Î“) in
+    let t' = hnf-qualif-term Î“ t in
+    let Î“' = ctxt-term-def pi globalScope x t' tp' Î“ in
       spanM-add (DefTerm-span Î“ pi x checking (just tp) t pi' []) â‰«span
       check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Î“)
         (spanM-add (Var-span Î“' pi x checking []) â‰«span
          spanMr (mk-toplevel-state use-cede make-rkt ip fns is Î“')))
 
-process-cmd (mk-toplevel-state use-cede make-rkt ip fns is Î“) (DefTermOrType (DefTerm pi x (Type tp) t) pi') ff {- skip checking -} = 
+process-cmd (mk-toplevel-state use-cede make-rkt ip fns is Î“) (DefTermOrType (DefTerm pi x (Type tp) t) pi') ff {- skip checking -} =
+  let tp' = qualif-type Î“ tp in
+  let t' = hnf-qualif-term Î“ t in
     check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Î“)
-      (spanMr (mk-toplevel-state use-cede make-rkt ip fns is (ctxt-term-def pi globalScope x (hnf Î“ unfold-head t tt) tp Î“)))
+      (spanMr (mk-toplevel-state use-cede make-rkt ip fns is (ctxt-term-def pi globalScope x t' tp' Î“)))
 
 process-cmd (mk-toplevel-state use-cede make-rkt ip fns is Î“) (DefTermOrType (DefTerm pi x NoCheckType t) pi') _ = 
   set-ctxt Î“ â‰«span
   check-term t nothing â‰«=span Î» mtp â†’ 
   get-ctxt (Î» Î“ â†’ 
     let t = erase-term t in
+    let t' = hnf-qualif-term Î“ t in
       spanM-add (DefTerm-span Î“ pi x synthesizing mtp t pi' []) â‰«span
       check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Î“)
-        (spanMr (mk-toplevel-state use-cede make-rkt ip fns is (h Î“ (hnf Î“ unfold-head t tt , mtp)))))
+        (spanMr (mk-toplevel-state use-cede make-rkt ip fns is (h Î“ (t' , mtp)))))
   where h : ctxt â†’ term Ã— (maybe type) â†’ ctxt
         h Î“ (t , nothing) = ctxt-term-udef pi globalScope x t Î“
         h Î“ (t , just tp) = ctxt-term-def pi globalScope x t tp Î“
@@ -71,24 +76,30 @@
 process-cmd (mk-toplevel-state use-cede make-rkt ip fns is Î“) (DefTermOrType (DefType pi x k tp) pi') tt {- check -} =
     set-ctxt Î“ â‰«span
     check-kind k â‰«span 
-    check-type tp (just k) â‰«span 
+    let k' = qualif-kind Î“ k in
+    check-type tp (just k') â‰«span 
     get-ctxt (Î» Î“ â†’ 
-      let Î“' = (ctxt-type-def pi globalScope x (hnf Î“ unfold-head tp tt) k Î“) in
+      let tp' = hnf-qualif-type Î“ tp in
+      let Î“' = ctxt-type-def pi globalScope x tp' k' Î“ in
         spanM-add (DefType-span Î“ pi x checking (just k) tp pi' []) â‰«span
         check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Î“)
           (spanM-add (TpVar-span Î“' pi x checking []) â‰«span
            spanMr (mk-toplevel-state use-cede make-rkt ip fns is Î“')))
 
 process-cmd (mk-toplevel-state use-cede make-rkt ip fns is Î“) (DefTermOrType (DefType pi x k tp) pi') ff {- skip checking -} = 
-  check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Î“)
-    (spanMr (mk-toplevel-state use-cede make-rkt ip fns is (ctxt-type-def pi globalScope x (hnf Î“ unfold-head tp tt) k Î“)))
+  let k' = qualif-kind Î“ k in
+  let tp' = hnf-qualif-type Î“ tp in
+    check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Î“)
+      (spanMr (mk-toplevel-state use-cede make-rkt ip fns is (ctxt-type-def pi globalScope x tp' k' Î“)))
 
 process-cmd (mk-toplevel-state use-cede make-rkt ip fns is Î“) (DefKind pi x ps k pi') tt {- check -} =
   set-ctxt Î“ â‰«span
   check-and-add-params pi' ps â‰«=span Î» ms â†’ 
   check-kind k â‰«span
   get-ctxt (Î» Î“ â†’ 
-    let Î“' = (ctxt-kind-def pi x ps (hnf Î“ unfold-head k tt) Î“) in
+    let k' = hnf-qualif-kind Î“ k in
+    -- TODO maybe need to qualif params ps
+    let Î“' = ctxt-kind-def pi x ps k' Î“ in
       spanM-add (DefKind-span Î“ pi x k pi') â‰«span
       check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Î“)
        (spanM-add (KndVar-span Î“' pi x (ArgsNil (posinfo-plus-str pi x)) checking []) â‰«span
@@ -104,8 +115,9 @@
         check-and-add-params _ ParamsNil = spanMr []
 
 process-cmd (mk-toplevel-state use-cede make-rkt ip fns is Î“) (DefKind pi x ps k pi') ff {- skip checking -} = 
-  check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Î“)
-    (spanMr (mk-toplevel-state use-cede make-rkt ip fns is (ctxt-kind-def pi x ps (hnf Î“ unfold-head k tt) Î“)))
+  let k' = hnf-qualif-kind Î“ k in
+    check-redefined pi x (mk-toplevel-state use-cede make-rkt ip fns is Î“)
+      (spanMr (mk-toplevel-state use-cede make-rkt ip fns is (ctxt-kind-def pi x ps k' Î“)))
 
 process-cmd s (Import pi x pi') _ = 
   let cur-file = ctxt-get-current-filename (toplevel-state.Î“ s) in
Index: src/rename.agda
===================================================================
--- src/rename.agda	(revision 27194)
+++ src/rename.agda	(working copy)
@@ -3,7 +3,7 @@
 open import lib
 
 open import cedille-types 
-open import ctxt
+open import ctxt-types
 open import is-free
 open import syntax-util
 
Index: src/subst.agda
===================================================================
--- src/subst.agda	(revision 27194)
+++ src/subst.agda	(working copy)
@@ -3,7 +3,7 @@
 open import lib
 
 open import cedille-types
-open import ctxt
+open import ctxt-types
 open import is-free
 open import rename
 open import general-util
@@ -53,6 +53,12 @@
 substh-term{TERM} Î“ Ï Ïƒ (Var pi x) =
  let x' = renamectxt-rep Ï x in
    trie-lookup-else (Var pi x') Ïƒ x'
+substh-term{ARG} Î“ Ï Ïƒ (Var pi x) =
+ let x' = renamectxt-rep Ï x in
+   inst-lookup-term pi Ïƒ x'
+substh-term{QUALIF} Î“ Ï Ïƒ (Var pi x) =
+ let x' = renamectxt-rep Ï x in
+   qualif-lookup-term pi Ïƒ x'
 substh-term Î“ Ï Ïƒ (Var pi x) = Var pi (renamectxt-rep Ï x)
 substh-term Î“ Ï Ïƒ (Unfold pi t) = Unfold pi (substh-term Î“ Ï Ïƒ t)
 substh-term Î“ Ï Ïƒ (Beta pi ot) = Beta pi (substh-optTerm Î“ Ï Ïƒ ot)
@@ -95,6 +101,12 @@
 substh-type{TYPE} Î“ Ï Ïƒ (TpVar pi x) =
  let x' = renamectxt-rep Ï x in
    trie-lookup-else (TpVar pi x') Ïƒ x'
+substh-type{ARG} Î“ Ï Ïƒ (TpVar pi x) =
+ let x' = renamectxt-rep Ï x in
+   inst-lookup-type pi Ïƒ x'
+substh-type{QUALIF} Î“ Ï Ïƒ (TpVar pi x) =
+ let x' = renamectxt-rep Ï x in
+   qualif-lookup-type pi Ïƒ x'
 substh-type Î“ Ï Ïƒ (TpVar pi x) = TpVar pi (renamectxt-rep Ï x)
 substh-type Î“ Ï Ïƒ (TpHole pi) = TpHole pi --ACG
 substh-kind Î“ Ï Ïƒ (KndArrow k kâ‚) = KndArrow (substh-kind Î“ Ï Ïƒ k) (substh-kind Î“ Ï Ïƒ kâ‚)
@@ -104,6 +116,8 @@
     KndPi pi pi' x' (substh-tk Î“ Ï Ïƒ atk)
       (substh-kind (ctxt-var-decl posinfo-gen x' Î“) (renamectxt-insert Ï x x') Ïƒ k)
 substh-kind Î“ Ï Ïƒ (KndTpArrow t k) = KndTpArrow (substh-type Î“ Ï Ïƒ t) (substh-kind Î“ Ï Ïƒ k)
+substh-kind{QUALIF} Î“ Ï Ïƒ (KndVar pi x xs) =
+   qualif-lookup-kind pi (substh-args Î“ Ï Ïƒ xs) Ïƒ x
 substh-kind Î“ Ï Ïƒ (KndVar pi x xs) = KndVar pi x (substh-args Î“ Ï Ïƒ xs)
 substh-kind Î“ Ï Ïƒ (Star pi) = Star pi
 
@@ -160,3 +174,14 @@
 rename-kind Î“ x y tt k = subst-kind Î“ (Var posinfo-gen y) x k
 rename-kind Î“ x y ff k = subst-kind Î“ (TpVar posinfo-gen y) x k
 
+substs-ret-t : Set â†’ Set
+substs-ret-t T = {ed : exprd} â†’ ctxt â†’ trie âŸ¦ ed âŸ§ â†’ T â†’ T
+
+substs-term : substs-ret-t term
+substs-term Î“ = substh-term Î“ empty-renamectxt
+
+substs-type : substs-ret-t type
+substs-type Î“ = substh-type Î“ empty-renamectxt
+
+substs-kind : substs-ret-t kind
+substs-kind Î“ = substh-kind Î“ empty-renamectxt
Index: src/syntax-util.agda
===================================================================
--- src/syntax-util.agda	(revision 27194)
+++ src/syntax-util.agda	(working copy)
@@ -12,8 +12,11 @@
 dummy-var : var
 dummy-var = "_dummy"
 
+qualif-info : Set
+qualif-info = var Ã— args
+
 qualif : Set
-qualif = trie (var Ã— args)
+qualif = trie qualif-info
 
 posinfo-to-â„• : posinfo â†’ â„•
 posinfo-to-â„• pi with string-to-â„• pi
@@ -39,34 +42,69 @@
   TpLambda posinfo-gen posinfo-gen x tk (abs-expand-type ps t)
 abs-expand-type ParamsNil t = t
 
-inst-kind : params â†’ args â†’ kind â†’ kind
-inst-kind ps as k = k
-
-inst-type : params â†’ args â†’ type â†’ type
-inst-type ps as t = t
-
-qualif-term : qualif â†’ term â†’ term
-qualif-term Ïƒ t = t
-
-qualif-type : qualif â†’ type â†’ type
-qualif-type Ïƒ t = t
-
-qualif-kind : qualif â†’ kind â†’ kind
-qualif-kind Ïƒ k = k
+-- qualify variable by module name
+_#_ : string â†’ string â†’ string
+fn # v = fn ^ "." ^  v
+
+mk-inst : params â†’ args â†’ trie arg
+mk-inst (ParamsCons (Decl _ _ x _ _) ps) (ArgsCons a as) =
+  trie-insert (mk-inst ps as) x a
+mk-inst _ _ = empty-trie
+
+apps-term : term â†’ args â†’ term
+apps-term f (ArgsNil _) = f
+apps-term f (ArgsCons (TermArg t) as) = apps-term (App f NotErased t) as
+apps-term f (ArgsCons (TypeArg t) as) = apps-term (AppTp f t) as
+
+apps-type : type â†’ args â†’ type
+apps-type f (ArgsNil _) = f
+apps-type f (ArgsCons (TermArg t) as) = apps-type (TpAppt f t) as
+apps-type f (ArgsCons (TypeArg t) as) = apps-type (TpApp f t) as
+
+append-params : params â†’ params â†’ params
+append-params (ParamsCons p ps) qs = ParamsCons p (append-params ps qs)
+append-params ParamsNil qs = qs
+
+append-args : args â†’ args â†’ args
+append-args (ArgsCons p ps) qs = ArgsCons p (append-args ps qs)
+append-args (ArgsNil _) qs = qs
+
+qualif-lookup-term : posinfo â†’ qualif â†’ string â†’ term
+qualif-lookup-term pi Ïƒ x with trie-lookup Ïƒ x
+... | just (x' , as) = apps-term (Var pi x') as
+... | _ = Var pi x
+
+qualif-lookup-type : posinfo â†’ qualif â†’ string â†’ type
+qualif-lookup-type pi Ïƒ x with trie-lookup Ïƒ x
+... | just (x' , as) = apps-type (TpVar pi x') as
+... | _ = TpVar pi x
+
+qualif-lookup-kind : posinfo â†’ args â†’ qualif â†’ string â†’ kind
+qualif-lookup-kind pi xs Ïƒ x with trie-lookup Ïƒ x
+... | just (x' , as) = KndVar pi x' (append-args as xs)
+... | _ = KndVar pi x xs
+
+inst-lookup-term : posinfo â†’ trie arg â†’ string â†’ term
+inst-lookup-term pi Ïƒ x with trie-lookup Ïƒ x
+... | just (TermArg t) = t
+... | _ = Var pi x
+
+inst-lookup-type : posinfo â†’ trie arg â†’ string â†’ type
+inst-lookup-type pi Ïƒ x with trie-lookup Ïƒ x
+... | just (TypeArg t) = t
+... | _ = TpVar pi x
 
 params-to-args : params â†’ args
 params-to-args ParamsNil = ArgsNil posinfo-gen
 params-to-args (ParamsCons (Decl _ p v (Tkt t) _) ps) = ArgsCons (TermArg (Var p v)) (params-to-args ps)
 params-to-args (ParamsCons (Decl _ p v (Tkk k) _) ps) = ArgsCons (TypeArg (TpVar p v)) (params-to-args ps)
 
--- TODO file-qualify once environment defs are also file-qualified
 qualif-insert-params : qualif â†’ var â†’ var â†’ params â†’ qualif
-qualif-insert-params Ïƒ fn v ps = trie-insert Ïƒ v (v , params-to-args ps)
+qualif-insert-params Ïƒ fn v ps = trie-insert Ïƒ v (fn # v , params-to-args ps)
 
--- TODO qualify codomain of import
-qualif-insert-import : qualif â†’ ğ•ƒ string â†’ args â†’ qualif
-qualif-insert-import Ïƒ [] as = Ïƒ
-qualif-insert-import Ïƒ (v :: vs) as = qualif-insert-import (trie-insert Ïƒ v (v , as)) vs as
+qualif-insert-import : qualif â†’ var â†’ ğ•ƒ string â†’ args â†’ qualif
+qualif-insert-import Ïƒ fn [] as = Ïƒ
+qualif-insert-import Ïƒ fn (v :: vs) as = qualif-insert-import (trie-insert Ïƒ v (fn # v , as)) fn vs as
 
 tk-is-type : tk â†’ ğ”¹
 tk-is-type (Tkt _) = tt
@@ -205,18 +243,24 @@
   TYPE : exprd
   KIND : exprd
   LIFTINGTYPE : exprd
+  ARG : exprd
+  QUALIF : exprd
 
 âŸ¦_âŸ§ : exprd â†’ Set
 âŸ¦ TERM âŸ§ = term
 âŸ¦ TYPE âŸ§ = type
 âŸ¦ KIND âŸ§ = kind
 âŸ¦ LIFTINGTYPE âŸ§ = liftingType
+âŸ¦ ARG âŸ§ = arg
+âŸ¦ QUALIF âŸ§ = qualif-info
 
 exprd-name : exprd â†’ string
 exprd-name TERM = "term"
 exprd-name TYPE = "type"
 exprd-name KIND = "kind"
 exprd-name LIFTINGTYPE = "lifting type"
+exprd-name ARG = "argument"
+exprd-name QUALIF = "qualification"
 
 -- checking-sythesizing enum
 data checking-mode : Set where
Index: src/to-string.agda
===================================================================
--- src/to-string.agda	(revision 27194)
+++ src/to-string.agda	(working copy)
@@ -5,7 +5,6 @@
 open import syntax-util
 open import ctxt
 
-
 markup-h : (tags : ğ•ƒ string) â†’ (vals : ğ•ƒ string) â†’ string â†’ string
 markup-h (th :: t) (vh :: vt) s = markup-h t vt (s ^ (" " ^ th ^ "='" ^ vh ^ "'"))
 -- Had to use "t" to refer to the tag tail since "tt" is the name for the Boolean true
@@ -78,7 +77,9 @@
 tk-to-string : ctxt â†’ tk â†’ string
 liftingType-to-string : ctxt â†’ liftingType â†’ string
 liftingType-to-stringh : {ed : exprd} â†’ ctxt â†’ âŸ¦ ed âŸ§ â†’ liftingType â†’ string
+qualif-to-string : ctxt â†’ qualif-info â†’ string
 maybeAtype-to-string : ctxt â†’ maybeAtype â†’ string
+arg-to-string : ctxt â†’ arg â†’ string
 args-to-string : ctxt â†’ args â†’ string
 
 -- If the first or second argument (toplevel, locally-not-needed) is true, don't put parens; else put parens
@@ -92,6 +93,7 @@
 type-to-string Î“ toplevel tp = type-to-stringh Î“ toplevel star tp
 kind-to-string Î“ toplevel k = kind-to-stringh Î“ toplevel star k
 liftingType-to-string Î“ l = liftingType-to-stringh Î“ star l
+qualif-to-string Î“ (x , as) = x ^ args-to-string Î“ as
 
 term-to-stringh Î“ toplevel p (App t x t') = 
   parens-unless toplevel ((is-beta p) || (is-app p)) (term-to-stringh Î“ ff (App t x t') t ^ " " ^ (maybeErased-to-string x) ^ term-to-string Î“ ff t')
@@ -160,8 +162,9 @@
 kind-to-stringh Î“ toplevel p (KndVar _ x ys) = x ^ args-to-string Î“ ys
 kind-to-stringh Î“ toplevel p (Star _) = "â˜…"
 
-args-to-string Î“ (ArgsCons (TermArg t) ys) = " " ^ term-to-string Î“ ff t ^ args-to-string Î“ ys
-args-to-string Î“ (ArgsCons (TypeArg t) ys) = " Â· " ^ type-to-string Î“ ff t ^ args-to-string Î“ ys
+arg-to-string Î“ (TermArg t) = term-to-string Î“ ff t
+arg-to-string Î“ (TypeArg t) = type-to-string Î“ ff t
+args-to-string Î“ (ArgsCons y ys) = " " ^ arg-to-string Î“ y ^ args-to-string Î“ ys
 args-to-string _ (ArgsNil _) = ""
 
 liftingType-to-stringh Î“ p (LiftArrow t tâ‚) = 
@@ -194,12 +197,13 @@
 maybeAtype-to-string _ NoAtype = ""
 maybeAtype-to-string Î“ (Atype T) = type-to-string Î“ ff T
 
-
 to-string : {ed : exprd} â†’ ctxt â†’ âŸ¦ ed âŸ§ â†’ string
 to-string{TERM} Î“ = term-to-string Î“ tt
 to-string{TYPE} Î“ = type-to-string Î“ tt
 to-string{KIND} Î“ = kind-to-string Î“ tt
 to-string{LIFTINGTYPE} = liftingType-to-string
+to-string{ARG} = arg-to-string
+to-string{QUALIF} = qualif-to-string
 
 to-string-if : ctxt â†’ {ed : exprd} â†’ maybe (âŸ¦ ed âŸ§) â†’ string
 to-string-if mÎ“ (just e) = to-string mÎ“ e
Index: src/toplevel-state.agda
===================================================================
--- src/toplevel-state.agda	(revision 27194)
+++ src/toplevel-state.agda	(working copy)
@@ -141,6 +141,6 @@
 scope-imports s import-fn with toplevel-state.Î“ s
 ... | mk-ctxt (fn , ps , q) syms i symb-occs with trie-lookup syms import-fn
 ... | nothing = s
-... | just vs = let q' = qualif-insert-import q vs (ArgsNil posinfo-gen) in
+... | just vs = let q' = qualif-insert-import q import-fn vs (ArgsNil posinfo-gen) in
   record s { Î“ = mk-ctxt (fn , ps , q') syms i symb-occs }
 
